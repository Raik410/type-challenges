var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/value-to-tree-object.ts
async function valueToTreeObject(octokit, owner, repo, path, value) {
  if (typeof value === "string") {
    return {
      path,
      mode: "100644",
      content: value
    };
  }
  const { data } = await octokit.request("POST /repos/:owner/:repo/git/blobs", __spreadValues({
    owner,
    repo
  }, value));
  const blobSha = data.sha;
  return {
    path,
    mode: "100644",
    sha: blobSha
  };
}

// src/create-tree.ts
async function createTree(state, changes) {
  const {
    octokit,
    owner,
    repo,
    latestCommitSha,
    latestCommitTreeSha
  } = state;
  const tree = (await Promise.all(Object.keys(changes.files).map(async (path) => {
    const value = changes.files[path];
    if (value === null) {
      try {
        await octokit.request("HEAD /repos/:owner/:repo/contents/:path", {
          owner,
          repo,
          ref: latestCommitSha,
          path
        });
        return {
          path,
          mode: "100644",
          sha: null
        };
      } catch (error) {
        return;
      }
    }
    if (typeof value === "function") {
      let result;
      try {
        const { data: file } = await octokit.request("GET /repos/:owner/:repo/contents/:path", {
          owner,
          repo,
          ref: latestCommitSha,
          path
        });
        result = await value(Object.assign(file, { exists: true }));
      } catch (error) {
        if (error.status !== 404)
          throw error;
        result = await value({ exists: false });
      }
      if (result === null || typeof result === "undefined")
        return;
      return valueToTreeObject(octokit, owner, repo, path, result);
    }
    return valueToTreeObject(octokit, owner, repo, path, value);
  }))).filter(Boolean);
  if (tree.length === 0)
    return null;
  const {
    data: { sha: newTreeSha }
  } = await octokit.request("POST /repos/:owner/:repo/git/trees", {
    owner,
    repo,
    base_tree: latestCommitTreeSha,
    tree
  });
  return newTreeSha;
}

// src/create-commit.ts
async function createCommit(state, treeCreated, changes) {
  const { octokit, repo, owner, latestCommitSha } = state;
  const message = treeCreated ? changes.commit : typeof changes.emptyCommit === "string" ? changes.emptyCommit : changes.commit;
  const { data: latestCommit } = await octokit.request("POST /repos/:owner/:repo/git/commits", {
    owner,
    repo,
    message,
    tree: state.latestCommitTreeSha,
    parents: [latestCommitSha],
    author: changes.author
  });
  return latestCommit.sha;
}

// src/create-pull-request.ts
async function PushCommit(octokit, {
  owner,
  repo,
  base,
  head,
  createWhenEmpty,
  changes: changesOption,
  fresh
}) {
  const changes = Array.isArray(changesOption) ? changesOption : [changesOption];
  if (changes.length === 0) {
    throw new Error('[octokit-plugin-create-pull-request] "changes" cannot be an empty array');
  }
  const state = { octokit, owner, repo };
  const { data: repository } = await octokit.request("GET /repos/:owner/:repo", {
    owner,
    repo
  });
  if (!repository.permissions) {
    throw new Error("[octokit-plugin-create-pull-request] Missing authentication");
  }
  if (!base)
    base = repository.default_branch;
  const {
    data: [latestCommit]
  } = await octokit.request("GET /repos/:owner/:repo/commits", {
    owner,
    repo,
    sha: base,
    per_page: 1
  });
  state.latestCommitSha = latestCommit.sha;
  state.latestCommitTreeSha = latestCommit.commit.tree.sha;
  const baseCommitTreeSha = latestCommit.commit.tree.sha;
  for (const change of changes) {
    let treeCreated = false;
    if (change.files && Object.keys(change.files).length) {
      const latestCommitTreeSha = await createTree(state, change);
      if (latestCommitTreeSha) {
        state.latestCommitTreeSha = latestCommitTreeSha;
        treeCreated = true;
      }
    }
    if (treeCreated || change.emptyCommit !== false) {
      state.latestCommitSha = await createCommit(state, treeCreated, change);
    }
  }
  const hasNoChanges = baseCommitTreeSha === state.latestCommitTreeSha;
  if (hasNoChanges && createWhenEmpty === false)
    return null;
  if (fresh) {
    await octokit.rest.git.createRef({
      owner,
      repo,
      sha: state.latestCommitSha,
      ref: `refs/heads/${head}`
    });
  } else {
    await octokit.rest.git.updateRef({
      owner,
      repo,
      sha: state.latestCommitSha,
      ref: `heads/${head}`,
      force: true
    });
  }
  return state;
}
async function CreatePullRequest(octokit, {
  owner,
  repo,
  title,
  body,
  base,
  head,
  labels
}) {
  return await octokit.request("POST /repos/:owner/:repo/pulls", {
    owner,
    repo,
    head: `${owner}:${head}`,
    base,
    title,
    body,
    labels
  });
}
export {
  CreatePullRequest,
  PushCommit
};
